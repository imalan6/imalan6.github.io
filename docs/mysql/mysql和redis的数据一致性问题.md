# mysql和redis的数据一致性问题

## 简介

在现如今的系统架构中，缓存的地位是非常重要的。当请求并发量比较高时，直接访问数据库是不现实的，可能直接拖垮数据库。所以，必须在数据库之上加一个缓存，方便请求快速读取数据。

不过，由此产生的问题也是很多的，其中一个就是如何保证数据库和缓存之间的数据一致性。

## 常见缓存方案

![0.png](https://i.loli.net/2021/04/18/HZdNJyDxnXcSR6l.png)

在读取缓存的方式中，上图这种方式可以说是最为广泛使用的了。读本身是没有什么问题的，但是，写入缓存的方式，就是保证数据一致性的关键了。

这里不考虑定时刷新缓存的方式，也就是类似下面这种方式：

![1.png](https://i.loli.net/2021/04/18/8gpvWjbBTrCAndF.png)

写入数据库和写入缓存是独立的，写入数据库操作后，需要等待定时服务执行，执行完成后缓存数据才会刷新。这种方式会导致数据的不一致时间较长，数据刷新时，不管有没有改变的数据，都会重新加载，效率差。

## 更新缓存方案

#### 方案一：先更新数据库，再更新缓存

这套方案是最简单的一种缓存双写方案，流程如下：

![2.png](https://i.loli.net/2021/04/18/9nl3GBbtX6ACYEM.png)

使用这种双写的方案，只要在数据成功写入数据库后，刷新缓存就可以了，代码简单，维护也很简单。但是，简单的前提下，带来的问题也是很直接的。

首先，线程数据安全无法保证

例如：同时有两个请求会操作同一条数据，一个是请求A，一个是请求B。请求A需要先执行，请求B后执行，那么数据库的记录就是请求B执行后的记录。

但是，由于一些网络原因或者其他情况，最终执行的顺序可能就变成了：

![3.png](https://i.loli.net/2021/04/18/qrEAT2w3tKMIYOG.png)

> 请求A Update 数据库 -> 请求B Update 数据库 -> 请求B Update 缓存 -> 请求A Update 缓存。

这样会导致：

1. 数据库和缓存中的数据不一致，从而缓存中的数据就成为了脏数据。

2. 写入操作多于读操作，就会频繁的刷新缓存，但是这些数据根本没有被读过，浪费服务器资源。

#### 方案二：先更新缓存，再更新数据库

![4.png](https://i.loli.net/2021/04/18/lHEiJ7pDnKPU1BO.png)

同样地，仍然可能出现方案一中的问题，即

请求A更新缓存 -> 请求B更新缓存 -> 请求B更新数据库 -> 请求A更新数据库。

最后，导致数据库和缓存数据不一致。

#### 优化方案

给数据库和缓存分别加入`version`版本号字段，并规定更新操作时，只有`version`值更大才更新。

**1、针对先更新数据库，再更新缓存的方案：**

1）更新数据库时，`db-version`值+1，然后取出`db-version`值；

2）再更新缓存时，将取出的数据库`db-version`值和缓存`redis-version`值作比较；

3）如果`db-version`值更大则更新缓存，如果`redis-version`值更小则不更新缓存；

![5.png](https://i.loli.net/2021/04/18/kfMGilvo26Wc9nh.png)

**2、针对先更新缓存，再更新数据库的方案:**

1）更缓存时，`redis-version`值+1，然后取出`redis-version`值；

2）再更新数据库时，将取出的缓存`redis-version`值和数据库`db-version`值作比较；

3）如果`redis-version`值更大则更新数据库，如果`db-version`值更小则不更新数据库；

![6.png](https://i.loli.net/2021/04/18/VpWJdzNnbyi2vqo.png)

问题：针对以上两种优化方案，存在这样的问题，如果更新数据库失败时，如何处理？更新缓存失败时，又如何处理？

**如果更新数据库失败：**

对于优化方案1，如果更新数据库失败，不再更新缓存，数据一致；对于优化方案2，如果更新数据库失败，需要回滚缓存，这操作比较麻烦，需要额外处理。

**如果更新缓存失败：**

对于优化方案1，如果更新缓存失败，数据库回滚，数据一致。对于优化方案2，如果更新缓存失败，不再更新数据库，数据一致。

以上可以看出，优化方案1相比优化方案2更好。但其实都存在一定缺陷，即引入了`version`字段，增加了业务复杂度。所以，不采用更新缓存，而采用删除缓存的方案会更方便。

## 删除缓存方案

#### 方案三：先删除缓存，再更新数据库

先删除缓存，再更新数据库。这样，在更新数据库的前后，由于缓存中没有数据了，请求会穿透缓存到数据库直接读取数据再放入缓存。这样，缓存不会被频繁刷新。一次查询数据库操作也能接受，对性能影响不会太大。

![7.png](https://i.loli.net/2021/04/18/28aBvMwNDkUjqbV.png)

不过，这样也会出现问题。假如有两个请求，一个请求A，一个请求B，请求A执行更新操作，请求B读取数据。当并发量高的时候，就会出现以下情况：

![8.png](https://i.loli.net/2021/04/18/2N7vyBEclIZm9gr.png)

> 请求A进行写操作，删除缓存 -> 请求B查询缓存没有数据 -> 请求B查询数据库得到旧值 -> 请求B将旧值写入缓存 -> 请求A再将新值写入数据库

这时，数据库和缓存的数据又不一致了。

#### 方案四：先更新数据库，再删除缓存

![9.png](https://i.loli.net/2021/04/18/eCT9LHqI8WihyUv.png)

先更新数据库再删除缓存，可以避免方案三中出现的问题，但是可能导致短暂的数据库和缓存不一致，即更新了数据库，但是缓存中仍然是旧值。因此，最好采用双删策略。

#### 方案五：双删

先删除缓存，再更新数据库，最后再删除一次缓存。

![10.png](https://i.loli.net/2021/04/18/VorUH5ZWaRCjubD.png)

方案四和方案五看似可以的，但是如果数据库采用的是主从复制模式，又会产生问题。假如出现这样一种情况：请求A删除了缓存，请求A更新了主数据库，请求A也再次删除了缓存，请求A完成了所有的步骤。但是数据库集群中发生了延时，主从数据库的同步没有完成。而恰巧这时，请求B去查询缓存没有获得数据，然后请求B访问从数据库获得了旧值，请求B将旧值写入缓存，最后，当主从数据库同步完成时，数据库和缓存的数据就不一致了。如下图所示：

![11.png](https://i.loli.net/2021/04/18/4mT9zYMoyvJ1RiF.png)

针对这种情况，可以考虑第二次删除缓存操作适当延迟一段时间，等主从同步完成后，再删除缓存。这也就有了延时双删策略。

#### 方法六：延时双删

![12.png](https://i.loli.net/2021/04/18/Lml2pCwUQ3WVZye.png)

使用延时双删的策略，可以解决主从同步延迟引起的数据不一致的情况。但是又会出现另外两个问题：

1、第二次删除缓存的时间该延迟多久呢？如果延迟时间短了，可能主从同步仍然没有完成，如果延迟时间长了，必然会影响任务的执行；

2、如果第二次删除缓存失败了，那又可能出现数据不一致的情况；

#### 方案七：延时双删 + 队列

![13.png](https://i.loli.net/2021/04/18/ONdgAnmrcoJU1wM.png)

针对可能出现第二次删除缓存失败的情况，可以把第二次删除缓存的消息加入到队列中，如果队列执行失败，就再次回到队列执行，直到成功为止。

这样，既可以保证第二次删除缓存操作执行成功，同时也实现异步执行删除缓存的操作，防止请求等待延迟而阻塞。当然，可以使用延迟队列，让消息在指定时间（比如2秒）后被消费。

#### 方案八：双删 + 订阅从库Binlog + 队列

针对延时双删的另外一个问题，假如延迟一段时间后，主从同步还是没有完成，那么仍然可能出现数据不一致的情况。这时，可以采用订阅从库`Binlog`的方式来处理。当从库完成同步后，`Binlog`发生变化，这时候再考虑删除缓存就很安全了。方案如下图：

![14.png](https://i.loli.net/2021/04/18/9NCVlUyrfPKAo6k.png)

当然，订阅从库的`Binlog`方式处理起来比较重，可以根据实际的应用场景采用不同的方案。