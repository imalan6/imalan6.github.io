# Redis持久化方案

## 简介

`Redis`是一个内存数据库，数据都是存放在内存当中的，当服务器重启或宕机时就会导致内存数据丢失。如果`Redis`仅做为一个缓存服务器使用的话，数据丢失不会有太大影响，重启之后再次更新缓存就可以了。但是如果`Redis`做为内存数据库使用的话，遇到数据丢失，问题就比较麻烦了。比如电商系统的登录信息、购物车信息、用户浏览记录等保存在`Redis`的话，都会丢失的，是会影响用户使用的。所以，有必要对`Redis`中的数据进行持久化处理，保证即使重启或者宕机，数据还可以再次找回来不会丢失。

## 持久化

`Redis`提供了`RDB`和`AOF`两种持久化机制，用来解决数据丢失问题。

1）`RDB`方式（默认）

2）`AOF`方式

## RDB方式

`RDB`是`Redis`默认采用的持久化方式。`RDB`通过快照方式（snapshot）完成，当符合一定条件时，`Redis`会自动将内存中的数据生成快照并持久化到硬盘。触发`RDB`的机制又可分为手动触发与自动触发。

- ### 手动触发

有两个`Redis`命令可以用于生成`RDB`文件：

1）使用`save`命令，但是"save"命令将会阻塞我们的`Redis`服务器直到`RDB`完成，所以生产环境中一般不会使用该命令。 

2）使用`bgsave`命令，`Redis`会`fork`一个子进程来负责`RDB`持久化，完成持久化后自动结束子进程，所以阻塞只发生在fork的阶段。

- ### 自动触发

需要在`Redis`的配置文件`redis.conf`中加上save命令，如 "save m n"，代表在m秒内数据发生了n次修改就会使用`bgsave`命令自动触发`RDB`。

命令格式：save <seconds> <changes>

示例：

save 900 1 ： 表示15分钟（900秒钟）内至少1个键被更改则进行快照。

save 300 10 ： 表示5分钟（300秒）内至少10个键被更改则进行快照。

save 60 10000 ：表示1分钟内至少10000个键被更改则进行快照。

这是`Redis`默认配置信息，可以配置多个条件（每行配置一个条件），每个条件之间是或的关系。之所以配置多条规则，是因为`Redis`每个时段的读写请求不是均衡的，为了平衡性能与数据安全，可以自由定制什么情况下触发持久化。所以可以根据自身业务情况进行合理配置。

- ### 实现原理

1）使用fork函数复制一份当前进程的副本(子进程)；

2）父进程继续接收并处理客户端发来的命令，而子进程开始将内存中的数据写入硬盘中的临时文件；

3）当子进程写完所有数据后会用该临时文件替换旧的`RDB`文件，至此，一次快照操作完成。

![0.png](https://i.loli.net/2021/03/29/qzEC8DJw9UNjme1.png)

- ### 配置

修改`/etc/redis/redis.conf`配置文件

```java
save 900 1　　# 时间策略，在900秒之内，对数据库进行了至少1次修改。
save 300 10　　# 时间策略，在300秒之内，对数据库进行了至少10次修改。
save 60 10000　　# 时间策略，在60秒之内，对数据库进行了至少1000次修改。
dbfilename dump.rdb   #rdb文件名称
dir /var/lib/redis   #rdb文件保存路径 
stop-writes-on-bgsave-error yes   # 如果持久化出错，主进程是否停止写入 
rdbcompression yes    # 是否压缩 
rdbchecksum yes     # 导入时是否检查 
```

- ### 注意

`Redis`启动时会读取`RDB`快照文件，将数据加载到内存。根据数据量大小、结构和服务器性能的不同，加载的时间也不同。通常情况下，一千万个字符串类型的键，大小为 1 GB的快照文件加载到内存中大概需要 20 秒左右。

- ### 优缺点

**优点**

性能最高。因为在写快照文件时，父进程只需要`fork`出一个子进程，而无需执行任何磁盘I/O操作，然后这个子进程会处理接下来的所有保存工作。

**缺点**

可能导致数据丢失。因为最后一次快照之后的操作可能还没备份`Redis`就退出了，或者正在备份`Redis`宕机或重启了，就会丢失最后一次快照以后更改的所有数据。

简而言之，`RDB`比较适合大规模的数据恢复，如果业务对数据完整性和一致性要求不高的话，`RDB`是很好的选择。

## AOF方式

`AOF`的出现是为了弥补`RDB`数据丢失的问题，它采用日志的形式记录每一条更改`Redis`数据的命令，并将该命令写入硬盘中的`AOF`文件。这一过程会降低`Redis`的性能，但大部分情况下这个影响是能接受的，可以采用较快的硬盘（比如固态硬盘）来提高`AOF`的性能。`Redis`重启会根据日志文件的内容将记录的命令从头执行一次以完成数据的恢复工作。

默认情况下`Redis`没有开启`AOF（append only file）`持久化，可以通过修改`redis.conf`配置文件中的`appendonly`参数为`yes`来开启。

- ### 实现原理

**1）实现原理**

`Redis`每次更改数据的时候，`AOF`机制都会将命令记录到`AOF`文件，但由于操作系统的缓存机制，数据并没有实时写入到硬盘，而是进入硬盘缓存。再通过硬盘缓存机制刷新到`AOF`文件中。在`AOF`模式打开的情况下，服务器每执行一次写命令就会以协议格式将执行的写命令追加到`aof_buf`缓冲区的末尾。

`Redis`每执行完一次事件循环，就要考虑是否将缓冲区的数据写入`AOF`文件，写入同步策略有配置文件的`appendfsync`参数决定：

① `appendfsync always`   每次执行写入都会进行同步，将缓冲区所有内容写入并同步`AOF`文件，这个是最安全但是效率比较低的方式；

② `appendfsync everysec`（默认） 每一秒执行

③ `appendfsync no`  不主动进行同步操作，由操作系统决定，这个是最快但最不安全的方式。

![1.png](https://i.loli.net/2021/03/29/ge4lC6OKwBQsdI2.png)

Tips:

```tiki wiki
为了提高文件的写入效率，在现代操作系统中，当用户调用write函数，将一些数据写入到文件的时候，操作系统通常会将写入数据暂时保存在一个内存缓冲区里面，等到缓冲区的空间被填满、或者超过了指定的时限之后，才真正地将缓冲区中的数据写入到磁盘里面。这种做法虽然提高了效率，但也为写入数据带来了安全问题，因为如果计算机发生停机，那么保存在内存缓冲区里面的写入数据将会丢失。为此，系统提供了fsync和fdatasync两个同步函数，它们可以强制让操作系统立即将缓冲区中的数据写入到硬盘里面，从而确保写入数据的安全性。
```

**2）重写机制**

① `AOF`文件可能会随着`Redis`运行变得越来越大，可以利用`AOF`重写的功能，来控制`AOF`文件的大小。`AOF`重写功能会首先读取数据库中现有的键值对状态，然后使用一条命令来替代前面的多条命令，重写后的新`AOF`文件包含了恢复当前数据集所需的最小命令集合。

② `Redis`采用子进程处理`AOF`重写。`Redis`还设置了一个`AOF`重写缓冲区，这个缓冲区在子进程被创建之后开始使用。在这期间，所有命令会被存两份，一份在`AOF`缓存空间，一份在`AOF`重写缓冲区，当`AOF`重写完成之后，子进程发送信号给主进程，通知主进程将`AOF`重写缓冲区的内容添加到`AOF`文件中。

③ 整个重写操作是绝对安全的，因为`Redis`在创建新`AOF`文件的过程中，会继续将命令追加到现有的`AOF`文件里面，即使重写过程中发生宕机，现有的`AOF`文件也不会丢失。而一旦新`AOF`文件创建完毕，`Redis`就会从旧`AOF`文件切换到新`AOF`文件，并开始对新`AOF`文件进行追加操作。

④ `AOF`文件有序地保存了对`Redis`执行的所有修改操作， 这些修改操作以`Redis`协议的格式保存， 因此`AOF`文件的内容非常容易理解。

**3）`AOF`文件修复**

当程序正在对`AOF`文件进行写入操作时突然宕机，就很有可能造成`AOF`文件出错，那么`Redis`在重启时会拒绝载入这个`AOF`文件。当出现这种情况时，可以用以下方法修复出错的`AOF`文件：

① 为现有的`AOF`文件创建一个备份；

② 使用`Redis`附带的`redis-check-aof`程序对原来的`AOF`文件进行修复。

③ 重启`Redis`服务器，等待载入修复后的`AOF`文件，并进行数据恢复。

- ### 配置

```bash
#AOF 和 RDB 持久化方式可以同时启动并且无冲突。  
#如果AOF开启，启动redis时会加载aof文件，这些文件能够提供更好的保证。 
appendonly yes

# aof文件的文件名称。（默认是appendonly.aof）  
# appendfilename appendonly.aof 
#redis支持三种不同的写入方式：  
#  
# no:不调用，等待操作系统来清空缓冲区，很快。  
# always: 每次更新数据都写入仅增日志文件。慢，但是最安全。
# everysec: 每秒调用一次。折中。
appendfsync everysec  

# 设置为yes表示rewrite期间对新写操作不fsync,暂时存在内存中,等rewrite完成后再写入.官方文档建议如果你有特殊的情况可以配置为'yes'。但是配置为'no'是最为安全的选择。
no-appendfsync-on-rewrite no  

# 自动重写只增文件。  
# redis可以自动盲从的调用‘BGREWRITEAOF’来重写日志文件，如果日志文件增长了指定的百分比。  
# 当前AOF文件大小是上次日志重写得到AOF文件大小的二倍时，自动启动新的日志重写过程。
auto-aof-rewrite-percentage 100  
# 当前AOF文件启动新的日志重写过程的最小值，避免刚刚启动Reids时由于文件尺寸较小导致频繁的重写。
auto-aof-rewrite-min-size 64mb
```

## 小结

一般来说，如果对数据完整性要求非常高的话，应该同时使用两种持久化功能。如果能允许几分钟数据丢失情况，可以只使用`RDB`方式，性能更好。

有很多用户都只使用`AOF`方式，不推荐这样做。因为定时生成`RDB`快照非常便于`Redis`备份，并且`RDB`恢复数据的速度也比`AOF`快 。

两种持久化策略可以同时使用，也可以只使用其中一种。如果同时使用的话，`Redis`重启时会优先使用`AOF`文件恢复数据。

