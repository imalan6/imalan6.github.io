# JVM 垃圾回收机制

## GC 作用

垃圾回收`GC`（`Garbage Collection`）是`JVM`垃圾回收器提供的一种用于在空闲时间不定时回收无任何对象引用的对象占据的内存空间的一种机制，目的是为了清除不再使用的对象，从而释放内存空间。因为程序在运行过程中会不断的分配内存空间，如果不进行垃圾回收，内存迟早会被消耗空。除非内存无限大，我们可以任意的分配而不回收，否则垃圾回收是必须的。

## 对象引用关系

从`JDK 1.2`版本开始，Java 存在4种对象引用关系。什么的对象引用关系，决定了其是否需要被垃圾回收，以及被回收的时机。详见 [对象引用关系总结]()。

 1）强引用（Strong Reference）：如 “`Object obj = new Object()`”，这类引用是 Java 程序中最普遍的。只要强引用还存在，垃圾收集器就永远不会回收掉被引用的对象。

 2）软引用（Soft Reference）：它用来描述一些可能还有用，但并非必须的对象。在系统内存不够用时，这类引用关联的对象将被垃圾收集器回收。JDK1.2 之后提供了 SoftReference 类来实现软引用。

 3）弱引用（Weak Reference）：它也是用来描述非必须对象的，但它的强度比软引用更弱些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在 JDK1.2 之后，提供了`WeakReference`类来实现弱引用。

 4）虚引用（Phantom Reference）：最弱的一种引用关系，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的是希望能在这个对象被收集器回收时收到一个系统通知。JDK1.2 之后提供了`PhantomReference`类来实现虚引用。

## 对象存活分析算法

Java 语言规范没有明确说明 JVM 使用哪种垃圾回收算法，但是任何一种垃圾回收算法一般要做两件基本的事情：

1）找到所有存活对象。

2）回收被无用对象占用的内存空间，使该空间可被程序再次使用。

因此，垃圾收集器在对堆区和方法区进行回收前，首先要确定这些区域的对象哪些可以被回收，哪些还不能回收，这就需要先判断对象是否存活。常用的对象存活判定算法如下：

- **引用计数算法（Reference Counting）**

引用计数是垃圾收集器中的早期策略，这种方法很简单。它实际上是通过在每个对象头中分配一个空间来保存该对象被引用的次数。当一个对象被创建时，将其被引用的次数设置为1。当任何其它变量被赋值为这个对象的引用时，计数加1（比如：`a = b`，则b引用的对象实例的计数+1）。但当一个对象实例的某个引用超过了生命周期或者被赋值为一个新值时，也就是删除对该对象的引用时，对象实例的引用计数-1。当该对象的引用计数为0时，那么该对象就会被回收。

优点：引用计数收集器执行简单，判定效率高，交织在程序运行中。对程序不被长时间打断的实时环境比较有利。

缺点：无法检测对象之间的循环引用关系。同时，引用计数器增加了程序执行的开销。所以 Java 语言并没有选择这种算法进行垃圾回收。

如下代码：

```java
public class ReferenceTest {

    public static void main(String[] args) {
    
        TestObject object1=new TestObject();
        TestObject object2=new TestObject();
        
        object1.object=object2;
        object2.object=object1;
        
        object1=null;
        object2=null;
    }
}

class TestObject{
     TestObject object;
}
```

这段代码是用来验证引用计数算法不能检测出循环引用。最后面两句将`object1`和`object2`赋值为`null`，也就是说`object1`和`object2`指向的对象已经不可能再被访问，但是由于它们互相引用对方，导致它们的引用计数器都不为 0，那么垃圾收集器就永远不会回收它们。

引用计数垃圾收集机制是在引用计数变化为 0 的即刻发生，而且只针对某一个对象以及它所依赖的其它对象。所以，我们一般也称呼引用计数垃圾收集为直接的垃圾收集机制。而采用引用计数的垃圾收集机制将垃圾收集的开销分摊到整个应用程序的运行当中，而不是在进行垃圾收集时，要挂起整个应用的运行，直到对堆中所有对象的处理都结束。因此，采用引用计数的垃圾收集不属于严格意义上的 "`Stop-The-World`" 的垃圾收集机制。

- **可达性分析算法（根搜索算法）**

可达性分析算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，从一个节点`GC ROOT`开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的没有被引用到的节点，则被认为是无用的节点，将会被判定为是可回收的对象。

![0.png](https://i.loli.net/2021/03/06/8ZcgCutHnGMUXzw.png)

在 Java 语言中，将某些特殊的对象定义为`GC Roots`，包括下面几种：

1）虚拟机栈中引用的对象（栈帧中的本地变量表）；

2）方法区中类静态属性引用的对象；

3）方法区中常量引用的对象；

4）本地方法栈中 JNI（`Native`方法）引用的对象。

关于标记引用节点需要注意：

1）开始进行标记前，需要先暂停应用线程，否则如果对象图一直在变化的话是无法真正去遍历它的。暂停应用线程以便 JVM 可以更好地分析对象引用关系，这种情况被称之为安全点（Safe Point），这会触发一次`Stop The World(STW)`暂停。触发安全点的原因很多，但最常见的就是垃圾回收了。

2）暂停时间的长短并不取决于堆内对象的多少也不是堆的大小，而是存活对象的多少。因此，调高堆的大小并不会影响到标记阶段的时间长短。

另外，可达性分析算法能正确处理循环引用，保证每个活对象只会被访问一次就能确定其存活性。对象图里是否存在循环引用，可达性分析都能正确判断对象的存活与否。

## 垃圾回收（GC）算法

- **标记-清除算法（Mark-Sweep）**

这是最基础的垃圾回收算法，之所以说它是最基础的是因为它最容易实现，思想也是最简单的。标记-清除算法分为两个阶段：标记阶段和清除阶段。标记阶段的任务是标记出所有需要被回收的对象，清除阶段就是回收被标记的对象所占用的空间。具体过程如下图所示：

![1.png](https://i.loli.net/2021/03/06/YRdJEToj183wrUQ.png)

标记-清除算法采用从根集合（`GC Roots`）进行扫描，**对存活的对象进行标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收**，如下图所示。标记-清除算法不需要进行对象的移动，只需对不存活的对象进行处理，在存活对象比较多的情况下极为高效。

![4.png](https://i.loli.net/2021/03/06/1jrLxXva6zeWtFI.png)

优点：不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效。

缺点：1）标记和清除过程效率都不高。这种方法需要使用一个空闲列表来记录所有的空闲区域及大小，对空闲列表的管理也会增加工作量。2）标记清除后**会产生大量不连续的内存碎片**。碎片太多可能会导致后续过程中需要为大对象分配空间时无法找到足够的空间而再次触发新的垃圾回收动作。

- **复制算法（Copying）**

为了解决 Mark-Sweep 算法的缺陷，Copying 算法被提了出来。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用的内存空间一次清理掉，这样一来就不容易产生内存碎片的问题。具体过程如下图所示：

![8.png](https://i.loli.net/2021/03/06/xDK29TEaC8tBVdg.png)

这种算法虽然实现简单，运行高效也不容易产生内存碎片，但是内存使用率却大大降低，将能够使用的内存缩减到原来的一半。另外，Copying 算法的效率跟存活对象的数目有很大的关系，如果存活对象很多，那么 Copying 算法的效率将大大降低。

复制算法的提出是为了克服句柄的开销和解决内存碎片的问题。它开始时把堆分成一个对象面和多个空闲面，程序从对象面为对象分配空间，当对象满了，基于Copying 算法的垃圾收集就从根集合（`GC Roots`）中扫描活动对象，并将每个活动对象复制到空闲面，使得活动对象所占的内存之间没有空闲区域，这样空闲面变成了对象面，而原来的对象面变成了空闲面，程序会在新的对象面分配内存。

![5.png](https://i.loli.net/2021/03/06/cgHL89Al3DSIJ5V.png)

- **标记—整理算法（Mark-compact）**

为了解决 Copying 算法的缺陷，充分利用内存空间，提出了 Mark-Compact 算法。该算法的标记阶段和 Mark-Sweep 算法一样，但是在完成标记之后，它不是直接清理可回收对象，而是**将存活对象向一端移动，然后清理掉存活对象端边界以外的内存**。在把存活对象集中向某端移动过程中，不需要处理被标记为垃圾的对象，因为迟早会被回收，所以可以直接覆盖它们的内存空间。当存活对象移动完毕，除开存活对象端边界以外的剩余内存都是可回收的。

标记-整理算法是在标记-清除算法的基础上，又进行了对存活对象的移动，因此代价更高，但是却解决了内存碎片的问题。具体流程如下图：

![6.png](https://i.loli.net/2021/03/06/5uGXt3V1hnYOesa.png)

- **分代收集算法（Generational Collection）** 

分代收集算法是目前大部分 JVM 垃圾收集器采用的算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下**将堆区划分为新生代（Young Generation）和老年代（Tenured Generation），在堆区之外还有一个永久代（Permanet Generation）**。新生代的特点是每次垃圾回收时都有大量对象需要被回收，而老年代的特点是每次垃圾回收时只有少量对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。

目前大部分垃圾收集器对于**新生代都采取 Copying 算法**，因为新生代中每次垃圾回收都要回收大部分对象，也就是说需要复制的操作次数较少，但是实际项目中并不是按照 1 ：1 的比例来划分新生代空间的。一般来说是将新生代划分为一块较大的`Eden`空间和两块较小的`Survivor`空间（通常为 8 : 1 : 1）。每次使用`Eden`空间和其中的一块`Survivor`空间。当进行垃圾回收时，将`Eden`和`Survivor`中还存活的对象复制到另一块`Survivor`空间中，然后清理掉`Eden`和刚才使用过的`Survivor`空间。

而由于**老年代的特点是每次回收都只回收少量对象，所以一般使用的是 Mark-Compact 算法**。

![7.png](https://i.loli.net/2021/03/06/OnzBkfvbQAoqX3y.png)

**1、年轻代（Young Generation）的回收算法 (回收主要以 Copying 为主)**

a）所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。

b）新生代内存按照 8 : 1 : 1 的比例分为一个`eden`区和两个`survivor`（`survivor0`，`survivor1`）区。大部分对象在`Eden`区中生成。回收时先将`eden`区存活对象复制到一个`survivor0`区，然后清空`eden`区；当 survivor0 区也存放满了时，则将`eden`区和`survivor0`区存活对象复制到另一个`survivor1`区，然后清空`eden` 区和`survivor0`区，此时`survivor0`区是空的，然后将`survivor0`区和`survivor1`区交换，即保持`survivor1`区为空， 如此往复。当`Eden`区没有足够空间的时候就触发 jvm 发起一次`Minor GC`。

c）当`survivor1`区不足以存放`eden`和`survivor0`的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次`Full GC (Major GC)`，也就是新生代、老年代都进行回收。

d）新生代发生的`GC`叫做`Minor GC`，`Minor GC`发生频率比较高，且不一定等`Eden`区满了才触发。

**2、年老代（Old Generation）的回收算法（回收主要以 Mark-Compact 为主）**

a）在年轻代中经历了多次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。

b）内存比新生代也大很多（大概比例是 1 : 2），当老年代内存满时触发`Major GC`即`Full GC`，`Full GC`发生频率比较低，老年代对象存活时间比较长，存活率标记高。

**3、持久代（Permanent Generation）也就是方法区的回收算法**

持久代也称方法区，用于存放静态文件，如 Java 类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些`class`，例如`Hibernate`等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。

方法区存储内容是否需要回收的判断条件不一样。方法区主要回收的内容有：废弃常量和无用的类。对于废弃常量也可通过引用的可达性来判断，但是对于无用的类则需要同时满足下面 3 个条件：

a）该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例；

b）加载该类的`ClassLoader`已经被回收；

c）该类对应的`java.lang.Class`对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

永久代空间在 Java 8 中已经被移除。取而代之的是元空间（`MetaSpace`）。因此不会再出现 “`java.lang.OutOfMemoryError: PermGen error`” 错误。

## 垃圾回收器

按执行机制划分，Java 有四种类型的垃圾回收器，分别是：串行垃圾回收器（Serial Garbage Collector），并行垃圾回收器（Parallel Garbage Collector），并发标记扫描垃圾回收器（CMS Garbage Collector），G1垃圾回收器（G1 Garbage Collector）。

每种垃圾回收器都有自己的特点，适合不同的应用场景。我们可以通过设置不同的`JVM`参数选择不同的垃圾回收器。

- **串行垃圾回收器（Serial Garbage Collector）**

它为单线程环境设计，只使用一个单独的线程进行垃圾回收，运行时会冻结所有应用程序线程进行工作，可能不适合服务器环境。它最适合的是简单的命令行程序，是`client`级别默认的`GC`方式。

通过`JVM`参数`-XX:+UseSerialGC`可以使用串行垃圾回收器。

- **并行垃圾回收器（Parallel Garbage Collector）**

与串行垃圾回收器不同，它使用多线程进行垃圾回收。但当执行垃圾回收时，它也会冻结所有的应用程序线程。它是`JVM`默认垃圾回收器。适用于多`CPU`、对暂停时间要求较短的应用上，是`server`级别默认采用的`GC`方式。

通过`JVM`参数`-XX:+UseParallelGC`来强制指定，用`-XX:ParallelGCThreads=4`来指定线程数。

- **并发标记扫描垃圾回收器（CMS Garbage Collector）**

并发标记垃圾回收使用多线程扫描堆内存，标记需要清理的实例并清理被标记过的实例。并发标记垃圾回收器只会在下面两种情况持有应用程序所有线程。

1）当标记的引用对象在`Tenured`区域；

2）在进行垃圾回收的时候，堆内存的数据被并发改变。

相比并行垃圾回收器，并发标记扫描垃圾回收器使用更多的`CPU`来确保程序的吞吐量。如果可以分配更多`CPU`，那么并发标记扫描垃圾回收器是更好的选择。

通过`JVM`参数`-XX:+USeParNewGC`使用并发标记扫描垃圾回收器。

- **G1垃圾回收器（G1 Garbage Collector）**

`G1`是一种服务器端的垃圾收集器，应用在多处理器和大容量内存环境中，在实现高吞吐量的同时，尽可能的满足垃圾收集暂停时间的要求。

它是专门针对以下应用场景设计的：像`CMS`收集器一样，能与应用程序线程并发执行。整理空闲空间更快，需要`GC`停顿时间更好预测。不希望牺牲大量的吞吐性能，不需要更大的`Java Heap`。

`G1`收集器的设计目标是取代`CMS`收集器，它同`CMS`相比，在以下方面表现的更出色： 

1）`G1`是一个有整理内存过程的垃圾收集器，不会产生很多内存碎片。 

2）`G1`的`Stop The World(STW)`更可控，`G1`在停顿时间上添加了预测机制，用户可以指定期望停顿时间。

------------------------------

以上各种GC机制是需要组合使用的，指定方式由下表所示：

![2.png](https://i.loli.net/2021/03/06/WiJ8eX3FMmvzVYt.png)



