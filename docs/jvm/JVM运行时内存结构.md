# JVM 运行时内存结构

## JVM 内存结构概念

Java 虚拟机定义了程序运行期间会使用的各种运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机的退出而销毁；而另一些则与线程一一对应，随着线程的开始而创建，随着线程的结束而销毁。具体的运行时数据区如下图所示：

![0.png](https://i.loli.net/2021/03/06/bg195IrwWxjDu2Z.png)

在 Java 虚拟机规范中，定义了五种运行时数据区，分别是 Java 堆、方法区、虚拟机栈、本地方法区、程序计数器。其中 Java 堆和方法区是线程共享的。

## Java 堆

**Java 堆是所有线程共享的一块内存区域**，它在虚拟机启动时就会被创建，并且单个`JVM`进程有且仅有一个 Java 堆。**Java 堆是用来存放对象实例及数组的，代码中通过`new`关键字创建出来的对象都存放在这里。所以这里也是垃圾回收的主要目标，于是它又叫做`GC`堆**。根据垃圾回收器的规则，我们可以对 Java 堆进行进一步的划分，具体 Java 堆内存结构如下图所示：

![1.png](https://i.loli.net/2021/03/06/5UdrgeOFnfxhwJS.png)

我们可以将 Java 堆划分为新生代和老年代两个大模块。在新生代中，我们又可以进一步分为`Eden`空间、`From Survivor`空间（s0）、`To Survivor`空间（s1），Survivor 空间有一个为空，用于发生`GC`时存放存活对象，老年代存放的是经过多次`Minor GC`仍然存活的对象或者是一些大对象，`FGC`就是发生在老年代。

上面就是 Java 堆的具体结构，Java 堆中的各空间大小是可以动态控制的，主要通过这三个参数：

- **-Xms**：JVM 启动时申请的初始`Heap`值，默认为操作系统物理内存的1/64，例如`-Xms20m`
- **-Xmx**：JVM 可申请的最大`Heap`值，默认值为物理内存的1/4，例如`-Xmx20m`。最好将`-Xms`和`-Xmx`设为相同值，避免每次垃圾回收完成后 JVM 重新分配内存；
- **-Xmn**：设置新生代的内存大小，`-Xmn`是将`NewSize`与`MaxNewSize`设为一致，也可以分别设置这两个参数。

Java 虚拟机规范规定，Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。也就是说堆的内存是一块块拼凑起来的。要增加堆空间时，往上“拼凑”（可扩展性）即可，但当堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出`java.lang.OutOfMemoryError: Java heap space`异常。

## 方法区

**方法区（Method Area）与 Java 堆一样，是各个线程共享的内存区域**，是 Java 虚拟机中唯二的内存共享区域。在 Java 虚拟机规范中是这样定义方法区的：**它存储了每个类的结构信息，例如运行时常量池、字段、方法数据、构造函数和普通方法的字节码内容，还包括一些在类、实例、接口初始化时用到的特殊方法。**

方法区在虚拟机启动的时候被创建，虽然方法区是堆的逻辑组成部分，但是简单的虚拟机实现可以选择在这个区域不实现垃圾收集与压缩，方法区在实际内存空间中可以不是连续的，对于方法区的容量，你可以是固定的，也可以随着程序的执行动态扩展，并且在不需要过多空间时自动收缩。

上面都是 Java 虚拟机中的规范，来看看具体的实现，拿我们常用的`HotSpot`虚拟机来说，在 JDK1.8 之前，方法区也被称作为永久代，这个方法区会发生我们常见的`java.lang.OutOfMemoryError: PermGen space`异常，我们也可以通过启动参数来控制方法区的大小：

- **-XX:PermSize** 设置最小空间
- **-XX:MaxPermSize** 设置最大空间

在 JDK1.8 之后，HotSpot 虚拟机对方法区进行了改动，移除了永久代，将原来存放在永久代的数据迁移到 Java 堆和`Metaspace`，方法区被移至到了`Metaspace`，字符串常量移至`Java Heap`。也就是说从 JDK1.8 开始，`Metaspace`也就是我们所谓的方法区，为什么要做这个改变呢？可能是因为以下两点原因：

- 由于`PermGen`内存经常会溢出，引发恼人的`java.lang.OutOfMemoryError: PermGen`，因此`JVM`的开发者希望这一块内存可以灵活管理，不要再经常出现这样的`OOM`。
- 移除`PermGen`可以促进`HotSpot JVM`与`JRockit VM`的融合，因为`JRockit`没有永久代。

可以通过设置参数来控制`Metaspace`的空间大小，主要有以下几个命令：

- **-XX:MetaspaceSize** ：分配给类元数据空间（以字节计）的初始大小。`MetaspaceSize`的值设置的过大会延长垃圾回收时间。垃圾回收过后，引起下一次垃圾回收的类元数据空间的大小可能会变大。
- **-XX:MaxMetaspaceSize**： 分配给类元数据空间的最大值，超过此值就会触发`Full GC`，此值默认没有限制，但应取决于系统内存的大小。`JVM`会动态地改变此值。
- **-XX:MinMetaspaceFreeRatio**：表示一次`GC`以后，为了避免增加元数据空间的大小，空闲的类元数据的容量的最小比例，不够就会导致垃圾回收。
- **-XX:MaxMetaspaceFreeRatio**：表示一次`GC`以后，为了避免增加元数据空间的大小，空闲的类元数据的容量的最大比例，不够就会导致垃圾回收。

## Java 虚拟机栈

**每一个线程都拥有自己私有的 Java 虚拟机栈**。这个 Java 虚拟机栈跟线程同时创建，所以它跟线程有相同的生命周期。Java 虚拟机栈描述的是 Java 方法执行的内存模型：**每一个方法在执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息**，每一个方法从调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中的入栈到出栈的过程。

![4.jpg](https://i.loli.net/2021/03/06/WIwkb3tovTGZgaE.jpg)

**局部变量表存放了编译期可知的各种基本数据类型**（`boolean、byte、char、short、int、float、long、double`）、**对象引用**（`reference`类型，它不等同于对象本身。根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置）和`returnAddress`类型（指向了一条字节码指令的地址）。

其中 64 位长度的`long`和`double`类型的数据会占用 2 个局部变量空间（`Slot`），其余的数据类型只占用 1 个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。

Java 虚拟机栈既允许被实现成固定的大小，也允许根据计算动态来扩展和收缩。如果采用固定大小的话，每一个线程的 Java 虚拟机栈容量可以在线程创建的时候独立选定。在 Java 虚拟机栈中会发生两种异常：

- 如果线程请求分配的栈容量超过 Java 虚拟机栈允许的最大容量，Java 虚拟机将会抛出`StackOverflowError`异常；
- 如果 Java 虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存或者在创建新的线程时没有足够的内存去创建对应的 Java 虚拟机栈，那么虚拟机将会抛出`java.lang.OutOfMemoryError:Unable to create new native thread`异常。

## 程序计数器

**程序计数器也是线程私有的**，它只需要一块较小的内存空间，你可以把它看作当前线程所执行的字节码的行号指示器，在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是**通过改变这个计数器的值来选取下一条需要执行的字节码指令**，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

![5.jpg](https://i.loli.net/2021/03/06/gKJSmRr3CzwBNt6.jpg)

我们知道在多线程的情况下，并不是一条线程一直执行完，而是多个线程轮流切换执行，所以为了线程切换后能够恢复到正确的执行位置，我们就需要程序计数器来告诉线程接下来该执行哪条指令。如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址，如果正在执行的是`Natvie`方法，这个计数器值则为空（`Undefined`）。

需要特别注意的是，**程序计数器是唯一一个在 Java 虚拟机规范中没有规定任何`OutOfMemoryError`情况的区域**。

## 本地方法栈

本地方法栈（`Native Method Stacks`）与 Java 虚拟机栈所发挥的作用是非常相似的，其区别不过是 Java 虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而**本地方法栈则是为虚拟机使用到的 Native 方法服务**。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如`Sun HotSpot`虚拟机）直接就把本地方法栈和虚拟机栈合二为一。

与 Java 虚拟机栈一样，本地方法栈区域也会抛出`StackOverflowError`和`OutOfMemoryError`异常。

## 常见内存溢出错误

有了对`JVM`内存结构的清晰认识，就可以帮助我们理解不同的`OutOfMemoryErrors`，下面列举一些比较常见的内存溢出错误，通过查看冒号“：”后面的提示信息，基本上就能断定是`JVM`运行时数据的哪个区域出现了问题。

```java
Exception in thread “main”: java.lang.OutOfMemoryError: Java heap space
```

原因：对象不能被分配到堆内存中。

----------------------------------------------------------------------------

```java
Exception in thread “main”: java.lang.OutOfMemoryError: PermGen space
```

原因：类或者方法不能被加载到老年代。它可能出现在一个程序加载很多类的时候，比如引用了很多第三方的库。

-------------------------------------------------------

```java
Exception in thread “main”: java.lang.OutOfMemoryError: Requested array size exceeds VM limit
```

原因：创建的数组大于堆内存的空间。

-----------------------

```java
Exception in thread “main”: java.lang.OutOfMemoryError: request <size> bytes for <reason>. Out of swap space?
```

原因：分配本地分配失败。`JNI`、本地库或者Java虚拟机都会从本地堆中分配内存空间。

-----------------------------------------------

```java
Exception in thread “main”: java.lang.OutOfMemoryError: <reason> <stack trace>（Native method）
```

原因：同样是本地方法内存分配失败，只不过是`JNI`或者本地方法或者 Java 虚拟机发现。

## 小结

JVM 采用栈和堆的设计思路，使得**栈是运行时的单位，而堆是存储的单位**。栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪儿。

在 Java 中，一个线程有相应的一个线程栈与之对应，因为不同的线程执行逻辑有所不同，因此需要一个独立的线程栈。而堆则是所有线程共享的。栈因为是运行单位，因此里面存储的信息都是跟当前线程（或程序）运行相关信息的。包括局部变量、程序运行状态、方法返回值等；而堆只负责存储对象信息。

栈是程序运行最根本的东西，程序运行可以没有堆，但是不能没有栈。而堆是为栈进行数据存储服务的，是一块共享的内存。不过，正是因为栈和堆分离设计的思想，才使得 Java 的垃圾回收更方便。

在 Java 中，`main`方法就是栈的起始点，也是程序的起始点。程序要运行总是有一个起点的。同 C 语言一样，Java 中的`main`就是那个起点，无论什么 Java 程序，找到`main`方法，就找到了程序执行的入口。程序运行永远都是在栈中进行的，因而参数传递时，只存在传递基本类型和对象引用的问题，不会直接传对象本身。

JVM 内存结构的基本情况大致总结如下：

![3.jpg](https://i.loli.net/2021/03/06/54iTvngbsVR9KHY.jpg)